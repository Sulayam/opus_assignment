from fastapi import FastAPI, HTTPException, Depends # type: ignore
from fastapi.security import HTTPBasic, HTTPBasicCredentials # type: ignore
import secrets
from fastapi.responses import JSONResponse  # type: ignore
from dotenv import load_dotenv
import os
from models import insert_log, insert_vendor, find_vendor_by_name, find_vendor_by_id
from database import init_db
from datetime import datetime
from compliance import run_compliance, required_docs_for_country
from documents.schemas import (
    DocumentRequirementsRequest,
    DocumentRequirementsResponse
)
from documents.service import get_required_documents


app = FastAPI()
security = HTTPBasic()


# --------------------------------------------------
# BASIC AUTH CONFIG
# --------------------------------------------------
# Load environment variables from .env file
load_dotenv()

# Access variables
VALID_USERNAME = os.getenv('VALID_USERNAME')
VALID_PASSWORD = os.getenv('VALID_PASSWORD')

def authenticate(credentials: HTTPBasicCredentials = Depends(security)):
    correct_username = secrets.compare_digest(credentials.username, VALID_USERNAME)
    correct_password = secrets.compare_digest(credentials.password, VALID_PASSWORD)
    if not (correct_username and correct_password):
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    return credentials.username



@app.on_event("startup")
def startup():
    init_db()

@app.get("/")
def root():
    return {
        "status": "ok",
        "service": "vendor-backend",
        "endpoints": [
            "/health",
            "/vendor/log",
            "/vendor/create",
            "/vendor/check-duplicate/{vendor_name}"
        ]
    }


@app.get("/health")
def health():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }


@app.post("/vendor/log")
async def log_vendor(data: dict):
    insert_log(data)
    return {
        "message": "Log entry recorded",
        "received": data
    }


@app.post("/vendor/create")
async def create_vendor(data: dict):
    """
    Creates a vendor record from the payload generated by Opus Code: Generate Vendor ID.
    """

    required_fields = ["vendor_id", "company_name", "requestor_email"]

    for field in required_fields:
        if field not in data:
            raise HTTPException(status_code=400, detail=f"Missing required field: {field}")

    vendor_name = data["company_name"]
    vendor_id = data["vendor_id"]

    # heck if vendor_id already exists
    if find_vendor_by_id(vendor_id):
        return JSONResponse(
            status_code=409,
            content={"message": "Vendor ID already exists", "duplicate": True}
        )

    # Check name duplication (less strict match)
    existing = find_vendor_by_name(vendor_name)
    if existing:
        return {
            "message": "Vendor name already exists",
            "duplicate": True,
            "existing_vendor": dict(existing)
        }


    vendor_row = {
        "vendor_id": vendor_id,
        "vendor_company_name": vendor_name,
        "requestor_email": data["requestor_email"],
        "country": data.get("country"),
        "annual_spend": data.get("estimated_annual_spend"),
        "payment_terms": data.get("payment_terms_days"),
        "created_at": data.get("timestamp", datetime.utcnow().isoformat()),
        "status": data.get("status", "initiated")
    }

    print("Creating vendor:", vendor_row)
    insert_vendor(vendor_row)

    return {
        "message": "Vendor created successfully",
        "duplicate": False,
        "vendor": vendor_row
    }


@app.get("/vendor/check-duplicate/{vendor_name}")
def check_duplicate(vendor_name: str):
    existing = find_vendor_by_name(vendor_name)

    if existing:
        return {"duplicate": True, "existing_record": dict(existing)}

    return {"duplicate": False}

@app.post("/compliance/check")
async def compliance_check(payload: dict):
    """
    Basic compliance screening + document-matrix lookup.
    Expects:
    {
        "vendor_id": "...",
        "company_name": "...",
        "country": "...",
        "policy_code": "basic_sanctions"   # optional
    }
    """
    required_fields = ["vendor_id", "company_name", "country"]
    for f in required_fields:
        if f not in payload:
            raise HTTPException(status_code=400, detail=f"Missing {f}")

    # run check
    result = run_compliance({
        **payload,
        "check_type": payload.get("policy_code", "basic_sanctions"),
        "requested_at": datetime.utcnow().isoformat()
    })
    return result


@app.get("/compliance/rules/{country}")
def compliance_rules(country: str):
    """
    Returns required document list for a given country.
    """
    return required_docs_for_country(country)

@app.post("/docs/requirements", response_model=DocumentRequirementsResponse)
async def get_document_requirements(payload: DocumentRequirementsRequest):
    """
    Returns country-specific document requirements for vendor onboarding.
    """
    required_docs = get_required_documents(payload.country)

    return {
        "vendor_id": payload.vendor_id,
        "country": payload.country,
        "required_documents": required_docs,
        "document_count": len(required_docs)
    }

