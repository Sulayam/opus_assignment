from fastapi import FastAPI, HTTPException, Depends  # type: ignore
from fastapi.security import HTTPBasic, HTTPBasicCredentials  # type: ignore
from fastapi.responses import JSONResponse  # type: ignore
import secrets
from dotenv import load_dotenv
import os
from models import insert_log, insert_vendor, find_vendor_by_name, find_vendor_by_id
from database import init_db
from datetime import datetime
from compliance import run_compliance, required_docs_for_country
from documents.schemas import (
    DocumentRequirementsRequest,
    DocumentRequirementsResponse
)
from documents.service import get_required_documents

# --------------------------------------------------
# APP + SECURITY SETUP
# --------------------------------------------------
app = FastAPI()
security = HTTPBasic()

# --------------------------------------------------
# BASIC AUTH CONFIG
# --------------------------------------------------
load_dotenv()  # Load .env file once

VALID_USERNAME = os.getenv("VALID_USERNAME")
VALID_PASSWORD = os.getenv("VALID_PASSWORD")

def authenticate(credentials: HTTPBasicCredentials = Depends(security)):
    """
    Authenticates incoming Basic Auth credentials.
    Safe comparison using `secrets.compare_digest` to avoid timing attacks.
    """
    correct_username = secrets.compare_digest(credentials.username, VALID_USERNAME or "")
    correct_password = secrets.compare_digest(credentials.password, VALID_PASSWORD or "")
    if not (correct_username and correct_password):
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    return credentials.username

# --------------------------------------------------
# STARTUP
# --------------------------------------------------
@app.on_event("startup")
def startup():
    init_db()

# --------------------------------------------------
# ROUTES
# --------------------------------------------------
@app.get("/")
def root():
    return {
        "status": "ok",
        "service": "vendor-backend",
        "auth_required": True,
        "endpoints": [
            "/health",
            "/vendor/log",
            "/vendor/create",
            "/vendor/check-duplicate/{vendor_name}",
            "/compliance/check",
            "/compliance/rules/{country}",
            "/docs/requirements"
        ]
    }

@app.get("/health")
def health():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }

# --------------------------------------------------
# VENDOR LOGGING (secured)
# --------------------------------------------------
@app.post("/vendor/log")
async def log_vendor(data: dict, username: str = Depends(authenticate)):
    insert_log(data)
    return {
        "message": "Log entry recorded",
        "user": username,
        "received": data
    }

# --------------------------------------------------
# VENDOR CREATION (secured)
# --------------------------------------------------
@app.post("/vendor/create")
async def create_vendor(data: dict, username: str = Depends(authenticate)):
    """
    Creates a vendor record from the payload generated by Opus Code: Generate Vendor ID.
    """

    print("a-Creating vendor with data:", data)
    required_fields = ["vendor_id", "company_name", "requestor_email"]
    for field in required_fields:
        if field not in data:
            raise HTTPException(status_code=400, detail=f"Missing required field: {field}")

    vendor_name = data["company_name"]
    vendor_id = data["vendor_id"]

    # ID duplication check
    if find_vendor_by_id(vendor_id):
        return JSONResponse(
            status_code=409,
            content={"message": "Vendor ID already exists", "duplicate": True}
        )

    print("b-Creating vendor with data:", data)
    # Name duplication check
    existing = find_vendor_by_name(vendor_name)
    if existing:
        return {
            "message": "Vendor name already exists",
            "duplicate": True,
            "existing_vendor": dict(existing)
        }

    vendor_row = {
        "vendor_id": vendor_id,
        "vendor_company_name": vendor_name,
        "requestor_email": data["requestor_email"],
        "country": data.get("country"),
        "annual_spend": data.get("estimated_annual_spend"),
        "payment_terms": data.get("payment_terms_days"),
        "created_at": data.get("timestamp", datetime.utcnow().isoformat()),
        "status": data.get("status", "initiated")
    }

    insert_vendor(vendor_row)

    return {
        "message": "Vendor created successfully",
        "duplicate": False,
        "vendor": vendor_row,
        "user": username
    }

# --------------------------------------------------
# DUPLICATE CHECK (secured)
# --------------------------------------------------
@app.get("/vendor/check-duplicate/{vendor_name}")
def check_duplicate(vendor_name: str, username: str = Depends(authenticate)):
    existing = find_vendor_by_name(vendor_name)
    if existing:
        return {"duplicate": True, "existing_record": dict(existing), "user": username}
    return {"duplicate": False, "user": username}

# --------------------------------------------------
# COMPLIANCE CHECK (secured)
# --------------------------------------------------
@app.post("/compliance/check")
async def compliance_check(payload: dict, username: str = Depends(authenticate)):
    """
    Basic compliance screening + document-matrix lookup.
    Expects:
    {
        "vendor_id": "...",
        "company_name": "...",
        "country": "...",
        "policy_code": "basic_sanctions"   # optional
    }
    """
    required_fields = ["vendor_id", "company_name", "country"]
    for f in required_fields:
        if f not in payload:
            raise HTTPException(status_code=400, detail=f"Missing {f}")

    result = run_compliance({
        **payload,
        "check_type": payload.get("policy_code", "basic_sanctions"),
        "requested_at": datetime.utcnow().isoformat()
    })
    result["checked_by"] = username
    return result

# --------------------------------------------------
# COMPLIANCE RULES (secured)
# --------------------------------------------------
@app.get("/compliance/rules/{country}")
def compliance_rules(country: str, username: str = Depends(authenticate)):
    result = required_docs_for_country(country)
    result["requested_by"] = username
    return result

# --------------------------------------------------
# DOCUMENT REQUIREMENTS (secured)
# --------------------------------------------------
@app.post("/docs/requirements", response_model=DocumentRequirementsResponse)
async def get_document_requirements(payload: DocumentRequirementsRequest, username: str = Depends(authenticate)):
    required_docs = get_required_documents(payload.country)
    return {
        "vendor_id": payload.vendor_id,
        "country": payload.country,
        "required_documents": required_docs,
        "document_count": len(required_docs),
        "requested_by": username
    }


@app.post("/vendor/document-issue")
async def log_document_issue(data: dict, username: str = Depends(authenticate)):
    """
    Logs rejected or incomplete document submissions.
    Called by Opus External Service: Log Document Rejection.
    """
    required_fields = ["vendor_id", "vendor_company_name", "requestor_email"]
    for f in required_fields:
        if f not in data:
            raise HTTPException(status_code=400, detail=f"Missing {f}")

    issue_entry = {
        "vendor_id": data["vendor_id"],
        "vendor_company_name": data["vendor_company_name"],
        "requestor_email": data["requestor_email"],
        "doc_contact_email": data.get("doc_contact_email"),
        "issue_type": data.get("issue_type", "missing_documents"),
        "issue_details": data.get("issue_details", {}),
        "status": "rejected",
        "logged_at": datetime.utcnow().isoformat()
    }

    from models import insert_document_issue
    insert_document_issue(issue_entry)

    return {
        "message": "Document issue logged successfully",
        "logged_by": username,
        "record": issue_entry
    }

@app.post("/test")
async def test_endpoint(data: dict, username: str = Depends(authenticate)):
    """
    Test endpoint to verify authentication and data reception.
    """
    return {
        "message": "Test endpoint reached successfully",
        "user": username,
        "received_data": data
    }